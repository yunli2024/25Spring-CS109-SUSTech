# ch 9 & 10 类与对象探究

### 1.构造函数 静态成员和实例成员

##### 	1.1 类的变量：private+setter&getter

​		如果是public的话，易于外部修改，不符合**encapsulation**的要求。

​		所以一般会使用private类型，下面写setter方法对变量进行修改，写getter方法对变量进行访问。



```java
//实例变量
private int hour;
//setter方法
public void setHour(int hour){
    this.hour=hour;
}
//getter方法,注意不用传递参数，因为hour是实例变量，这个类里面都可以访问到。
public int getHour(){
    return hour;
}
```



##### 		1.2构造函数及其重载

​		constructor是一个特殊的方法，与类名相同，通过传入的参数对类内变量进行初始化。

​		构造函数可以进行重载。

```java
public Time2(int h, int m, int s) {
    setTime(h, m, s);
  }//这是一个构造函数，设定了时间的初始值
  public Time2(int h, int m) {
    this(h, m, 0);
  }//使用this()方法对传入参数残缺的数据进行初始化。
//this()会调用最上面3参数的构造函数，并且为其提供h和m
```



##### 		1.3静态成员和实例成员

​		静态成员有静态变量和静态方法。

​		静态变量也就是类属性，是这个类的所有对象共享的值。在obj1里面修改了类属性，obj2也会同步修	改。相比之下，没有加static修饰的是实例变量，实例变量是依附于对象存在的，每创建一个新的对象，就会	产生一个实例变量的副本，所以彼此之间相互独立。

​		静态方法不能接受实例变量作为参数，只能接受静态变量，同时也不可以调用实例方法（也就是说不能	与一切non-static扯上关系）。而实例方法可以接受静态变量和实例变量。实例方法只有在实例化之后，通过	对象名调用，比如obj.get()； 静态方法则无需实例化，直接通过类名调用即可，比如Example.get();

​		需要注意的是，主方法main一定是一个static的方法，所以不能接受实例参数和实例方法。如果想调用或	者传参，又不想改成static，需要new一个对象之后，通过对象来进行一系列操作。

​		

##### 	1.4 组合composition

​		代码复用是OOP一个很重要的命题，通过composition和inheritance等手段，实现代码复用，避免重复	造轮子。

​		组合就是在一个类里面引用其他类的对象，从而有一个has-a关系。



### 2 包和包访问

#####  		2.1 package及其控制访问

​		包是类的集合，一个包包含了很多类。

​		默认的情况下代码被存放在默认包中，想要声明package的话，要在类的前面声明包，这样可以把类存放	在指定的包中。

​		注意类的一个.java文件的话，那包就相当于一个文件夹。**所以要做好包名和文件路径的对应**。

​		可以通过导入语句导入包中的某个类（或者整个包），这样就可以直接通过类名进行操作/实例化之后通	过对象操作。

​		特殊的静态导入：导入之后可以直接使用静态变量和静态方法，而不需要去加类名。

​		

```java
package ch10.cs109;//declare
import java.util.Scanner //import
import static java.lang.Math.*;//静态导入，可以直接使用静态成员了。之后就不用Math.PI了，直接PI
```

​		控制访问初步：

​		类成员（包括变量和方法）、类有以下控制访问标识：

​		**p s ：好像很多地方变量和方法都会看成一个整体，具有相同属性。符合我对 数据集+操作集的认知。

|               | 类成员                                                | 类                   |
| ------------- | ----------------------------------------------------- | -------------------- |
| public        | 可以被所有地方访问，只要导入了/实例化了这个类(World!) | 可以被所有地方访问   |
| 包私有（默认) | 可以被这个包里面的其他类访问                          | 可以被包内其他类访问 |
| private       | 只能被自己这个类访问                                  | 不存在！             |

​		

### 3 final关键字和枚举类型

##### 	3.1 final关键字

​		final关键字类似于const，设定一些常数值，值一旦确定就不可以修改了。

​		final是在运行时必须确定初始值。所以要直接初始化，或者在每一个构造函数里都对其传递值，不然的话就无法在运行之前确保他有值了。

##### 		3.2 enum 类型

​		枚举类型用于表示固定的一组常量。

​		枚举类型本质上继承自java.lang.Enum类，可以看成是一种特殊的类，用于储存常量（和一些方法）。	因此他会有一些类的操作，比如可以看成是引用数据类型，通过类名直接对（静态）元素进行访问等等。

​		println()一个类的时候，默认会toString之后再打印。



### 4 包装类和ArrayList

##### 		4.1 Wrapped Class

​		包装类是针对基础数据类型的提升。每一种基础数据类型都对应着一种包装类。

​		包装类的作用是，将基础数据类型变为类之后，可以拥有一些类的性质，便于面向对象操作。比如，想	要将块作用域内的形参影响实际参数，就需要用到。(?)

​		包装类还提供了丰富的操作方法，可以对基础数据类型进行操作。

​		后续的集合类和泛型也需要用到包装类（数据结构？留个坑）

​		

```java
//一些包装类的操作方法
Integer.parseInt("123");//字符串改成整数
Character.isDigit(c)//判断字符是不是数字
```

​		自动装箱和拆箱：

​		需要Integer类型的时候会自动变为……

```java
Integer[] array={1,2,3} //建了一个Integer类型的数组，元素会自动升级为Integer类型
int x=array[1]//自动拆箱为2赋值给x
```

##### 		

##### 		4.2 ArrayList

​		ArrayList是java中非常重要的数据结构，是一个动态数组，不需要指定初始的size！

​		但是需要注意的是，ArrayList（属于java中的集合框架）接受的Type不可以是基本数据类型，所以需要将基本类型改成包装类才可以。

​		ArrayList是泛型类，也可以当成类进行操作吧。留个坑后面学到再补。

​		感觉还有很多有意思的结构需要探索啊。。。

​		

```java
//declare 语法：ArrayList<Type> listName= new ArrayList<Type>();
ArrayList<Integer> IntList =new ArrayList<Integer>(); //为整数ArrayList实例化了一个对象
IntList.add(5);//在结尾插入元素5 Intlist是对象，调用方法直接用对象名.方法名（所以说泛型类也是类…？
			   //此处直接加了整数int，会自动装箱成为Integer
IntList.add(0,10);//在指定位置插入10，其余元素后移
int x = IntList.get(1);//获取指定位置的元素值 x=5

for (int i=0;i<10;i++)
        IntList.add(random.nextInt(1000));
        Collections.sort(IntList);//这个东西提供了Timsort，升序排序
        System.out.println(IntList);

ArrayList<?> list=new ArrayList<?>(); //使用通配符，不指定。
```

### 5 堆内存与栈内存 较为底层

##### 		5.1  堆内存和Garbage Collection

​		堆内存是JVM中一块很大的内存，用于储存实例化之后的**对象**，以及数组（包括基本类型数组和动态数	组）。每当new一个新的对象的时候，就会在堆内存中开启一块新的空间。

​		堆内存中的对象可以被其他地方引用访问（理解为指针）

​		GC垃圾回收机制：堆内存中的对象，在没有引用指向他们的时候，就会被自动回收掉，避免资源泄漏。

##### 		5.2 栈内存

​		栈内存是调用某个**方法**的时候，用来存储局部变量，方法参数，调用的上下文等，只在块作用域内会有	栈内存。当这个方法结束，离开块作用域，栈帧被弹出，栈内存就被回收了。

​		这一块可以看一些例子，去想想底层的图，获得更好的理解。